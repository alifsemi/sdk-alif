.. _alif_linker_workarounds:

Linker
######

Overview
********

This Zephyr module provides linker script fragments and build system integration to address specific issues when building
firmware with LLVM/Clang. The main problems addressed are:

1. Unwanted exception tables generated by Clang even when exceptions are disabled
2. ARM EABI relocation limitations with ``.ramfunc`` sections
3. Lack of proper support for the ``long_call`` attribute in Clang
4. Symbol table placement warnings from LLVM's linker

Features
********

- Automatic discard of exception table sections to prevent linker errors
- Integration with Zephyr's build system via Kconfig options
- Fixes for symbol table placement warnings

Usage
*****

This module is automatically enabled when using the LLVM toolchain with Zephyr when exceptions are disabled.
To manually control its behavior, you can set the following Kconfig options in your project's ``prj.conf``:

.. code-block:: none

   # Main configuration option
   CONFIG_ALIF_LINKER_WORKAROUNDS=y  # Enable all workarounds

   # Granular control over specific workarounds
   CONFIG_ALIF_DISCARD_EXCEPTION_TABLES=y  # Discard exception tables (.ARM.exidx)
   CONFIG_ALIF_FIX_SYMBOL_WARNINGS=y      # Fix symbol table placement warnings

For debug builds, you can keep the unwinding information while still discarding the exception tables that cause linker errors:

.. code-block:: none

   CONFIG_ALIF_DISCARD_EXCEPTION_TABLES=y  # Still needed to avoid linker errors

For optimal results with either configuration, also add these compiler flags:

.. code-block:: none

   CONFIG_EXCEPTIONS=n  # Disable C++ exceptions

Technical Details
*****************

Exception Tables and ARM EABI Limitations
===========================================

The ARM EABI specification defines a relocation type called ``R_ARM_PREL31`` which is used for exception handling tables
(``.ARM.exidx`` sections). This relocation has a limited range of ±1GB from the call site.

LLVM/Clang generates these exception tables for all functions by default, even when exceptions are disabled with
``-fno-exceptions``. This is a known issue and differs from GCC's behavior.

Alif Hardware Memory Layout
----------------------------

The Alif SoC architecture uses a memory layout where MRAM (Magnetoresistive RAM) and TCM (Tightly Coupled Memory)
are placed at addresses that are very far apart in the memory map:

- **MRAM**: Located at address ranges starting at 0x80000000
- **TCM**: Located at much lower addresses, typically around 0x00000000 - 0x00FFFFFF

When code is placed in MRAM and RAM functions (using the ``.ramfunc`` section) are placed in TCM, the distance between them
can be well over 1GB. This causes linker errors because the ``R_ARM_PREL31`` relocations cannot span this distance.

Error messages typically look like:

.. code-block:: none

   ld.lld: error: <internal>:(.ARM.exidx+0x0): relocation R_ARM_PREL31 out of range: -1610651068 is not in [-1073741824, 1073741823]; references section '.ramfunc'

**Solution**: The ``discard_exception_tables.ld`` script addresses this issue by discarding these unwanted exception tables when
the ``CONFIG_ALIF_DISCARD_EXCEPTION_TABLES`` option is enabled.

When Exception Tables Can Be Kept
----------------------------------

It's important to note that discarding exception tables is only necessary when your application has code that spans across
memory regions that are far apart in the address space (like MRAM and TCM). If your application code stays entirely within
a single memory region, such as:

- All code remains in MRAM (no ``.ramfunc`` sections)
- All code remains in I/DTCM (a fully RAM-resident application)

Then the exception tables can be kept without causing linker errors, because all the relocations will be within the ±1GB
range limit. In these cases, you can safely disable ``CONFIG_ALIF_DISCARD_EXCEPTION_TABLES`` if you need the exception
tables for other purposes, such as debugging or exception handling.

Function Call Range Issues
===========================

Lack of ``long_call`` Attribute Support
----------------------------------------

Unlike GCC, LLVM/Clang does not properly support the ``__attribute__((long_call))`` attribute for ARM targets.
This attribute is meant to ensure that function calls use a calling sequence that can reach any memory address,
but Clang ignores it.

Linker Veneers as an Alternative
--------------------------------

Instead of relying on the ``long_call`` attribute, modern ARM linkers (including LLVM's lld) use a technique called
"veneers" or "trampolines" to handle calls that exceed the normal branch instruction range. When the linker detects
that a function call target is too far away for a direct branch instruction, it automatically inserts a small piece
of code (the veneer) that uses a longer-range calling sequence.

How veneers work:

1. **Detection**: During linking, the linker calculates the distance between call sites and their targets
2. **Veneer Insertion**: If a call exceeds the branch range (±16MB for ARM Thumb branches), the linker inserts a veneer
3. **Redirection**: The original call is redirected to the veneer instead of directly to the target function
4. **Long Jump**: The veneer uses a PC-relative load or absolute addressing to reach the actual target

This approach is more efficient than using ``long_call`` for every function, as veneers are only inserted where needed.
However, it doesn't solve the issue with exception tables, which still require the workarounds provided by this module.

Linker Warning Issues
=====================

Symbol Table Placement Warnings
-------------------------------

LLVM's linker (ld.lld) generates warnings about symbol table placement that don't occur with other linkers:

.. code-block:: none

   ld.lld: warning: <internal>:(.symtab) is being placed in '.symtab'
   ld.lld: warning: <internal>:(.shstrtab) is being placed in '.shstrtab'
   ld.lld: warning: <internal>:(.strtab) is being placed in '.strtab'

These warnings are harmless but can clutter build output.

**Solution**: The ``symbol_tables.ld`` script addresses these warnings by explicitly defining these sections with the ``(INFO)`` attribute,
telling the linker these are informational sections that don't need to be loaded into memory.
This fix is enabled when the ``CONFIG_ALIF_FIX_SYMBOL_WARNINGS`` option is set.

Known Remaining Warnings
------------------------

When using LLVM's linker, you may still see this warning:

.. code-block:: none

   ld.lld: warning: ignoring memory region assignment for non-allocatable section '.last_section'

The warning occurs because Zephyr's linker script assigns the ``.last_section`` to a memory region, but this section
is marked as non-allocatable. Since this section doesn't need memory allocation, the warning is harmless and can be
safely ignored. Future versions of LLVM may fix this issue.
